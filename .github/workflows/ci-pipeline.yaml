# [Lior Dux] ==================== [ GitHub Actions CI-CD Pipelien ] ====================  [13-02-2023] #
# 
# Stages: Package, Test, Deliver, Deploy.
# 
# Notes:
# 1. Use quality actions only.
# 2. Prefer using actions to code.
# 3. Use secrets and vars where possible for dynamically and security.
# 4. TBD - decouple jobs furtur more, after figuring out how to pass files from one job to the other.
# 5. TBD - figure out how to use secret for the ECR and repo name for the build-push-docker action.
# 6. 
#
# Actions used:
# 1) (checkout@v3)[https://github.com/marketplace/actions/checkout]
# 2) (build-push-action@v2)[https://github.com/marketplace/docker/build-push-action]
# 3) (actions/upload-artifact@v3)[https://github.com/marketplace/actions/upload-a-build-artifact]
# 4) (aws-actions/configure-aws-credentials@v1)[https://github.com/marketplace/actions/configure-aws-credentials-action-for-github-actions]
# 5) (aws-actions/amazon-ecr-login@v1)[https://github.com/marketplace/actions/amazon-ecr-login-action-for-github-actions]
# 6) (actions/download-artifact@v3)[https://github.com/marketplace/actions/download-a-build-artifact]
# 7) ()[]
#
# GitHub OpenID Connect - https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services
#
name: ci-pipeline

on:
  push:
    branches: ['main', 'feature/*']
  pull_request:
    branches: ['main']

# permission can be added at job level or workflow level    
permissions:
  id-token: write # This is required for requesting the JWT
  contents: read  # This is required for actions/checkout

jobs:
  Build:
    runs-on: ubuntu-latest
    environment: Testing
    steps:
      # Git Clone
      - name: Checkout
        uses: actions/checkout@v3

      # Build the image
      - name: Package
        uses: docker/build-push-action@v2
        id: build-image
        with:
          context: ./GitHub-Actions/demodocker
          push: false
          tags: pipeline:current-build-test2 

      # Unit Test Current Build
      - name: Test
        working-directory: ./GitHub-Actions/demodocker
        run: |
          docker run --name dockertest -d pipeline:current-build-test2
          echo "Assume we have unit tests to run..."
          docker stop dockertest
  
  SemVer:
    # if: ${{ github.Action == pull_request }} #$(git rev-list --tags --max-count=1)
    needs: Build
    runs-on: ubuntu-latest
    environment: Testing
    outputs:
      current_build_tag: ${{ steps.pass_publish_tag.outputs.publish_tag }}
    steps:
      # Git Clone
      - name: Checkout
        uses: actions/checkout@v3

      # Grab the latest tag, form vX.X.X
      - name: Semver
        id: SemVer
        run: |
          git fetch --tags --all
          version=`git describe --tags $(git rev-list --tags --max-count=1) | cut -d 'v' -f2`
          echo "current_version=$version" >> $GITHUB_OUTPUT
        
      # Split current version 
      - name: Split tag
        id: minor
        run: |
          major=`echo "${{ steps.SemVer.outputs.current_version }}" | cut -d '.' -f 1`
          minor=`echo "${{ steps.SemVer.outputs.current_version }}" | cut -d '.' -f 2`
          patch=`echo "${{ steps.SemVer.outputs.current_version }}" | cut -d '.' -f 3`
          echo "major=$major" >> $GITHUB_OUTPUT
          echo "minor=$minor" >> $GITHUB_OUTPUT
          echo "patch=$patch" >> $GITHUB_OUTPUT

      # Update patch and pass current publish tag to the next job
      - name: Build next tag
        id: pass_publish_tag
        run: |
          next=`echo "(${{ steps.minor.outputs.patch }}+1)" | bc`
          echo "publish_tag=v${{ steps.minor.outputs.major }}.${{ steps.minor.outputs.minor }}.$next" >> $GITHUB_OUTPUT

  Publish:
    needs: SemVer
    runs-on: ubuntu-latest
    environment: Testing
    outputs:
      toTag: ${{ steps.toTag.outputs.toTag }}
    steps:

      # Grab passed tag from prev job
      - name: Test soon-to-be-published tag
        run: echo "${{ needs.SemVer.outputs.current_build_tag }}"

      # Set up AWS Auth
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          # role-to-assume: ${{ secrets.AWS_ASSUME_ROLE }}
          # role-session-name: samplerolesession
          # role-duration-seconds: 1200
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION }}
      
      # Delivery prep
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
      
      # Git Clone
      - name: Checkout
        uses: actions/checkout@v3

      # Publish
      - name: Build, tag, and push image to Amazon ECR
        uses: docker/build-push-action@v2
        id: build-image
        with:
          context: ./GitHub-Actions/demodocker
          push: true
          tags: 442284833462.dkr.ecr.eu-west-1.amazonaws.com/pipeline-test:0.1 
      
      # Pass tag to next job - GitTag
      - name: Pass soon-to-be-tagged tag
        id: toTag
        run: echo "toTag=${{ needs.SemVer.outputs.current_build_tag }}" >> $GITHUB_OUTPUT

  GitTag:
    needs: Publish
    runs-on: ubuntu-latest
    environment: Testing
    steps:

      # Grab passed tag from prev job
      - name: Test soon-to-be-tagged tag
        run: echo "${{ needs.Publish.outputs.toTag }}"

      # Git Clone
      - name: Checkout
        uses: actions/checkout@v3

      # Commit empty and tag local
      - name: Tag
        id: tag
        run: |
          git tag -a "${{ needs.Publish.outputs.toTag }}" -m "GitHub-Actions Tag Added Automatically - New Image Uploded ${{ needs.Publish.outputs.toTag }}"

      # Push commit and tag
      - name: Push-tag
        id: push-tag
        run: |
          git push origin ${{ needs.Publish.outputs.toTag }}
          echo "Git tag create successfully!"

  # Report on Slack
  slackNotification:
    name: Slack Notification
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Slack Notification
      uses: rtCamp/action-slack-notify@v2
      env:
        SLACK_CHANNEL: general
        SLACK_COLOR: ${{ job.status }} # or a specific color like 'good' or '#ff00ff'
        SLACK_ICON: https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png?size=48
        SLACK_MESSAGE: 'Post Content :rocket:'
        SLACK_TITLE: Post Title
        SLACK_USERNAME: GitHubBot
        SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
    if: always()